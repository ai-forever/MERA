import abc
import gc
import hashlib
import json
import os
import re
from abc import abstractmethod
from typing import Iterable
from itertools import repeat

import datasets
import numpy as np
import torch
import transformers
import torch.nn.functional as F
from accelerate import find_executable_batch_size
from accelerate.utils.memory import should_reduce_batch_size, is_xpu_available, is_npu_available
from sqlitedict import SqliteDict
from tqdm import tqdm

from lm_eval import utils
from lm_eval.metrics import bits_per_byte, mean, weighted_perplexity


class LM(abc.ABC):
    def __init__(self):
        self.cache_hook = CacheHook(None)

    @abstractmethod
    def loglikelihood(self, requests):
        """Compute log-likelihood of generating a continuation from a context.
        Downstream tasks should attempt to use loglikelihood instead of other
        LM calls whenever possible.

        :param requests: list
            A list of pairs (context, continuation)
            context: str
                Context string. Implementations of LM must be able to handle an
                empty context string.
            continuation: str
                The continuation over which log likelihood will be calculated. If
                there is a word boundary, the space should be in the continuation.
                For example, context="hello" continuation=" world" is correct.
        :return: list
            A list of pairs (logprob, isgreedy)
            logprob: float
                The log probability of `continuation`
            isgreedy:
                Whether `continuation` would be generated by greedy sampling from `context`
        """
        pass

    @abstractmethod
    def loglikelihood_rolling(self, requests):
        """Compute full log-likelihood of a string, with no truncation, for perplexity computation
        - We will use the full max context length of the model.
        - For inputs that exceed the max context length, we divide the tokenized string into chunks of up to
        the max context length.
        - IMPORTANT: Each document's loglikelihood/perplexity is computed *separately*, unlike other implementations
          which may simply concatenate multiple documents together.
        - IMPORTANT: We maximize the amount of context for each prediction. Specifically, for inputs that we break into
          multiple chunks, the last input will still a full-sized context.
          Example:
            Input tokens: [ 0 1 2 3 4 5 6 7 8 9 ]
            Prefix: EOT
            Max context length: 4
            Resulting input/prediction pairs:

                INPUT:  EOT   0   1   2
                PRED:     0   1   2   3

                INPUT:    3   4   5   6
                PRED:     4   5   6   7

                INPUT:    5   6   7   8
                PRED:             8   9

          Observe that:
            1. Each token is predicted exactly once
            2. For the last pair, we provide the full context, but only score the last two tokens

        :param requests: list
            A list of strings
            string: str
                String for which we are computing per-toke  loglikelihood
        :return: list
            A list of pairs (logprob, isgreedy)
            logprob: float
                The log probability of `continuation`
            isgreedy:
                Whether `continuation` would be generated by greedy sampling from `context`
        """
        pass

    # TODO: Add an optional max length
    @abstractmethod
    def greedy_until(self, requests):
        """Generate greedily until a stopping sequence

        :param requests: list
            A list of pairs (context, until)
            context: str
                Context string
            until: [str]
                The string sequences to generate until. These string sequences
                may each span across multiple tokens, or may be part of one token.
        :return: list
            A list of strings continuation
            continuation: str
                The generated continuation.
        """
        pass

    @classmethod
    def create_from_arg_string(cls, arg_string, additional_config=None):
        additional_config = {} if additional_config is None else additional_config
        args = utils.simple_parse_args_string(arg_string)
        args2 = {k: v for k, v in additional_config.items() if v is not None}
        return cls(**args, **args2)

    def set_cache_hook(self, cache_hook):
        self.cache_hook = cache_hook


class BaseLM(LM):
    def __init__(self):
        super().__init__()
        self.batch_schedule = 1
        self.batch_sizes = {}
        self.max_batch_size = 512

    @property
    @abstractmethod
    def eot_token_id(self):
        pass

    @property
    @abstractmethod
    def max_length(self):
        pass

    @property
    @abstractmethod
    def max_gen_toks(self):
        pass

    @property
    @abstractmethod
    def batch_size(self):
        pass

    @property
    @abstractmethod
    def device(self):
        pass

    @abstractmethod
    def tok_encode(self, string: str):
        pass

    @abstractmethod
    def tok_decode(self, tokens: Iterable[int]):
        pass

    def check_generation_ability(self):
        # if already checked, returne the result
        if hasattr(self, "_can_generate"):
            return self._can_generate
        # otherwise run checking with fail output
        else:
            self._can_generate = self.generation_available()
            return self._can_generate

    def generation_available(self):
        # check whether model can generate new tokens, as it needs for greedy_until reqs
        if not self.model.can_generate():
            print(
                "WARNING! The model you are currently trying to score the model that is supposed "
                "to be unable to generate tokens which is an essential part of the benchmark.\n"
                "If this behaviour is usual for your model, ignore this warning.\nOtherwise, "
                "consider using the other model that has `model.can_generate()` property set to `True` "
                "to be able to assess the performance of your model om generation tasks!"
            )
            return False
        else:
            # if it can, then need to check default position_ids generation for Causal
            try:
                inps = torch.tensor([10, 20, 30])
                attns = torch.tensor([0, 1, 1])
                new = self.model.prepare_inputs_for_generation(
                    input_ids=inps,
                    attention_mask=attns,
                )
                if "position_ids" not in new.keys() and "input_ids" not in new.keys():
                    print(
                        "Method `model.prepare_inputs_for_generation` does not "
                        "return input_ids and position_ids.\nUsing no preparation for "
                        "`model.forward`."
                    )
                    return False
                elif "position_ids" not in new.keys() and "input_ids" in new.keys():
                    print(
                        "Method `model.prepare_inputs_for_generation` does not "
                        "return position_ids.\nNo position_ids may lead to irreproducible "
                        "results."
                    )
                    return True
                elif "position_ids" in new.keys() and "input_ids" not in new.keys():
                    print(
                        "`model.prepare_inputs_for_generation` method does not "
                        "return input_ids.\nUsing no preparation for `model.forward`."
                    )
                    return False
                else:
                    print("Using `model.prepare_inputs_for_generation` method for `model.forward`.")
                    return True
            # any exception is considered a failure
            except Exception as e:
                print(
                    "While checking method `model.prepare_inputs_for_generation` for some "
                    f"input data an error occurred: {e}\n"
                    "Pay attention that the result of the scoring may depend on the length "
                    "of the sequences in a batch (if batch is more than 1).\nNo preparation means "
                    "no position_ids which may lead to irreproducible results."
                )
                return False

    def tokenizer_check(self):
        # check that the model has at least as many embeddings as there are tokens in the tokenizer
        if len(self.tokenizer) > len(list(self.model.parameters())[0]):
            print(
                "Warning! The length of the vocabulary of the tokenizer is more than "
                "the number of vectors in the first hidden layer.\nIf this is the Embedding layer, "
                "make sure you have embeddings for all tokens in the vocabulary."
            )
        # check tokenizer has EOS token, otherwise do nothing
        if self.tokenizer.eos_token is None:
            print("Tokenizer does not have eos_token!")

        # check tokenizer has BOS token, otherwise do nothing
        if self.tokenizer.bos_token is None:
            print("Tokenizer does not have eos_token!")

        # check tokenizer has unk_token_id. When trying to get id of a candidate
        # pad token it may appear, so check it exists
        if self.tokenizer.unk_token is None:
            print("Tokenizer does not have unk_token!")
            unk_id = -1
        else:
            unk_id = self.tokenizer.unk_token_id

        # need pad token for padding (batch > 1), if no then replace by eos
        if self.tokenizer.pad_token is None and self.batch_size != 1:
            print(
                "Warning! The tokenizer does not have pad_token with batch_size more than 1.\n"
                "If this is not the expected behaviour, check out the tokenizer you are using and "
                "tokenizer_config.json.\nSetting pad_token and equal to eos_token."
            )
            self.tokenizer.pad_token = self.tokenizer.eos_token
            self.tokenizer.pad_token_id = self.tokenizer.eos_token_id

    @abstractmethod
    def _model_generate(self, context, max_length, eos_token_id):
        pass

    @abstractmethod
    def _model_call(self, inps):
        """
        inps: a torch tensor of shape [batch, sequence]
        the size of sequence may vary from call to call

        returns: a torch tensor of shape [batch, sequence, vocab] with the
        logits returned from the model
        """
        pass

    def _detect_max_length(self, max_length=None, threshold: int = 100):
        if max_length is None:
            max_length = self.max_length

        def clear_cache():
            gc.collect()
            if is_xpu_available():
                torch.xpu.empty_cache()
            elif is_npu_available():
                torch.npu.empty_cache()
            else:
                torch.cuda.empty_cache()

        def proper_len_search(bottom_len, top_len, threshold):
            mid = (top_len + bottom_len) // 2

            # If OOM happened then proper length is even smaller
            if OOM_happened(mid):
                print("Searching for good max length. OOM at length", mid)
                clear_cache()
                return proper_len_search(bottom_len, mid - 1, threshold)

            # Else length is OK but may be too small â€” using threshold to check more search needed
            elif (top_len - mid) > threshold:
                print("length", mid, "not failed but it can be lengthier")
                clear_cache()
                return proper_len_search(mid, top_len, threshold)
            else:
                print(mid, "is good enough")
                clear_cache()
                return mid

        def OOM_happened(cur_length):
            oom = False
            try:
                test_batch = torch.ones((1, cur_length), device=self.device).long()
                test_attn = torch.ones((1, cur_length), device=self.device).long()
                test_conts = torch.ones((1, cur_length), device=self.device).long()
                call_args = {
                    "input_ids": test_batch,
                    "attention_mask": test_attn,
                    "labels": test_conts,
                }
                for _ in range(5):
                    out = F.log_softmax(self._model_call(call_args), dim=-1).cpu()
            except Exception as e:
                if should_reduce_batch_size(e):  # OOM happened
                    clear_cache()
                    oom = True
                else:
                    raise
            return oom

        if OOM_happened(max_length):
            print("Searching for good max length. OOM at length", max_length)
            clear_cache()
            max_length = proper_len_search(100, max_length, threshold)
        return max_length

    def _detect_batch_size(self, requests=None, pos: int = 0):
        if requests:
            # for loglike requests when know the longest request
            _, ctx = requests[pos]
            max_length = len(ctx[-(self.max_length + 1) :][:-1])
        else:
            max_length = self.max_length

        # if OOM, then halves batch_size and tries again
        @find_executable_batch_size(starting_batch_size=self.max_batch_size)
        def forward_batch(batch_size):
            batched_conts = torch.ones((batch_size, max_length), device=self.device).long()
            test_batch = torch.ones((batch_size, max_length), device=self.device).long()
            attn_batch = torch.ones((batch_size, max_length), device=self.device).long()
            call_args = {
                "input_ids": test_batch,
                "attention_mask": attn_batch,
                "labels": batched_conts,
            }
            for _ in range(5):
                out = F.log_softmax(self._model_call(call_args), dim=-1)

            return batch_size

        batch_size = forward_batch()
        utils.clear_torch_cache()
        return batch_size

    # subclass must implement properties vocab_size, eot_token_id, max_gen_toks, batch_size, device, max_length.
    # TODO: enforce this somehow

    def loglikelihood(self, requests, task=None):
        new_reqs = []
        for context, continuation in requests:
            ctx = self.tok_encode(context + continuation, False)
            new_reqs.append(((context, continuation), ctx))

        override_bs = None if task != "rutie" else 1

        return self._loglikelihood_tokens(new_reqs, override_bs=override_bs)

    def loglikelihood_rolling(self, requests):
        # TODO: Implement caching once we've confirmed the perplexity implementation
        # Not used so far

        # automatic batch size detection for vectorization
        adaptive_batch_size = None
        if self.batch_size == "auto":
            # using rolling window with maximum context
            print("Passed argument batch_size = auto. Detecting largest batch size")
            batch_size = self._detect_batch_size()
            print(f"Determined Largest batch size: {batch_size}")
            adaptive_batch_size = batch_size

        loglikelihoods = []
        for (string,) in tqdm(requests):
            rolling_token_windows = list(
                map(
                    utils.make_disjoint_window,
                    utils.get_rolling_token_windows(
                        token_list=self.tok_encode(string),
                        prefix_token=self.eot_token_id,
                        max_seq_len=self.max_length,
                        context_len=1,
                    ),
                )
            )

            rolling_token_windows = [(None,) + x for x in rolling_token_windows]

            # TODO: extract out this call so it only gets called once and also somehow figure out partial caching for
            # that
            string_nll = self._loglikelihood_tokens(
                rolling_token_windows,
                disable_tqdm=True,
                override_bs=adaptive_batch_size,
            )

            # discard is_greedy
            string_nll = [x[0] for x in string_nll]

            string_nll = sum(string_nll)
            loglikelihoods.append(string_nll)

        return loglikelihoods

    def _loglikelihood_tokens(self, requests, disable_tqdm=False, override_bs=None):
        # TODO: implement some kind of efficient-request-middleware that lumps together requests with the same context
        res = []

        def _collate(x):
            # the negative sign on len(toks) sorts descending - this has a few advantages:
            # - time estimates will always be over not underestimates, which is more useful for planning
            # - to know the size of a batch when going through the list, you know the first one is always the batch
            #   padded context length. this is useful to simplify the batching logic and more importantly to make
            #   automatic adaptive batches much much easier to implement
            # - any OOMs will happen right away rather than near the end

            toks = x[1]
            return -len(toks), tuple(toks)

        re_ord = utils.Reorderer(requests, _collate)

        reordered_requests = re_ord.get_reordered()
        n_reordered_requests = len(reordered_requests)

        # automatic (variable) batch size detection for vectorization
        # pull longest context sample from request
        def _batch_scheduler(pos):
            sched = pos // int(n_reordered_requests / self.batch_schedule)
            if sched in self.batch_sizes:
                return self.batch_sizes[sched]
            print(f"Passed argument batch_size = auto:{self.batch_schedule}. Detecting largest batch size")
            self.batch_sizes[sched] = self._detect_batch_size(reordered_requests, pos)
            print(f"Determined largest batch size: {self.batch_sizes[sched]}")
            return self.batch_sizes[sched]

        if len(reordered_requests) == 1:
            disable_tqdm = True

        for chunk in utils.chunks(
            tqdm(reordered_requests, disable=disable_tqdm),
            n=self.batch_size if self.batch_size != "auto" else override_bs if override_bs is not None else 0,
            fn=_batch_scheduler if self.batch_size == "auto" and n_reordered_requests > 0 and not override_bs else None,
        ):
            inps = []
            attns = []
            cont_toks_list = []
            inplens = []

            # dict for logs
            logs_ctx = {
                "tokenizer_pad_token": [self.tokenizer.pad_token, self.tokenizer.pad_token_id],
                "tokenizer_eos_token": [self.tokenizer.eos_token, self.tokenizer.eos_token_id],
                "tokenizer_bos_token": [self.tokenizer.bos_token, self.tokenizer.bos_token_id],
                "attr_batch_size": self.batch_size if self.batch_size != "auto" else self.batch_sizes,
                "attr_max_length": self.max_length,
                "input_ids_check": [],
                "real_tokens_count": [],
            }

            padding_length = None

            # because vectorizing is annoying, we first convert each (context, continuation) pair to padded
            # tensors, then we pack them together into a batch, call the model, and then pick it all apart
            # again because vectorizing is annoying

            for _, ctx in chunk:
                # sanity check
                assert len(ctx) > 0
                assert len(ctx) <= self.max_length

                # how this all works:
                #          CTX      CONT
                # inp    0 1 2 3|4 5 6 7 8 9   <- last token is deleted by inp[:, :-1]
                # gpt2    \               \
                # logits   1 2 3|4 5 6 7 8 9   <- the ctx half gets tossed out by the
                # cont_toks      4 5 6 7 8 9      [:, -len(continuation_enc):, :self.vocab_size] slice

                # when too long to fit in context, truncate from the left
                # truncate the last token - do not need its probs
                inp = torch.tensor(
                    ctx[-(self.max_length + 1) :][:-1],
                    dtype=torch.long,
                ).to(self.device)
                (inplen,) = inp.shape

                # continuation from 2 token till end
                cont = torch.tensor(
                    ctx[-(self.max_length + 1) :][1:],
                    dtype=torch.long,
                )

                logs_ctx["input_ids_check"].extend([[sum(inp.tolist()[1:]), sum(cont.tolist()[:-1])]])
                assert inp.tolist()[1] == cont.tolist()[0] and len(inp.tolist()) == len(cont.tolist())

                # since in _collate we make sure length is descending, the longest is always the first one.
                padding_length = padding_length if padding_length is not None else inplen

                # pad length from seq to padding_length from LEFT side
                attn = torch.cat(
                    [
                        torch.zeros(padding_length - inplen, dtype=torch.long).to(inp.device),
                        torch.ones_like(inp).to(inp.device),
                    ],
                    dim=0,
                )
                inp = torch.cat(
                    [
                        torch.zeros(padding_length - inplen, dtype=torch.long).to(inp.device),  # [padding_length - seq]
                        inp,  # [seq]
                    ],
                    dim=0,
                )

                inps.append(inp.unsqueeze(0))  # [1, padding_length]
                attns.append(attn.unsqueeze(0))
                cont_toks_list.append(cont)
                inplens.append(inplen)

                logs_ctx["real_tokens_count"].extend([attn.sum(dim=-1).item()])

            if len(inps) == 1:
                batched_inps = {"input_ids": inps[0], "attention_mask": attns[0]}
            else:
                # TODO: better replace torch.cat with smth else to preserve memory
                batched_inps = {"input_ids": torch.cat(inps, dim=0), "attention_mask": torch.cat(attns, dim=0)}
            try:
                if self.AUTO_MODEL_CLASS == transformers.AutoModelForCausalLM:
                    multi_logits = F.log_softmax(
                        self._model_call(batched_inps), dim=-1
                    ).cpu()  # [batch, padding_length, vocab]
                elif self.AUTO_MODEL_CLASS == transformers.AutoModelForSeq2SeqLM:
                    multi_logits = F.log_softmax(self._model_call(batched_inps, batched_inps), dim=-1).cpu()
            except Exception as e:
                error_msg = {
                    "header": "Error occurred while processing loglikelyhood requests for seq2seq models",
                    "content": e,
                    "chunk": chunk,
                }
                print(error_msg)
                raise

            for (cache_key, _), logits, inplen, cont, ctx_logs in zip(
                chunk,
                multi_logits,
                inplens,
                cont_toks_list,
                zip(
                    logs_ctx["input_ids_check"],
                    logs_ctx["real_tokens_count"],
                    repeat(logs_ctx["tokenizer_pad_token"]),
                    repeat(logs_ctx["tokenizer_eos_token"]),
                    repeat(logs_ctx["tokenizer_bos_token"]),
                    repeat(logs_ctx["attr_batch_size"]),
                    repeat(logs_ctx["attr_max_length"]),
                ),
            ):
                # consider no special tokens have been added
                # truncate left-side padding logits
                logits = logits[-inplen:].unsqueeze(0)  # [1, seq, vocab]

                # Check if per-token argmax is exactly equal to continuation
                greedy_tokens = logits.argmax(dim=-1)
                # TODO: greedy only for continuation tokens
                max_equal = (greedy_tokens == cont).all()

                # Obtain log-probs for the entire input sequence
                # last_token_slice = logits[:, -1, :].squeeze(0).tolist()
                # cont should have tokens over [1, THIS, 1] dimension
                logits = torch.gather(logits, 2, cont.unsqueeze(-1).unsqueeze(0)).squeeze(-1)  # [1, seq]

                # Answer: (log prob, is-exact-match)
                answer = (float(logits.sum()), bool(max_equal))

                # partial caching
                if cache_key is not None:
                    self.cache_hook.add_partial("loglikelihood", cache_key, answer)

                res.extend(
                    [
                        [
                            answer,
                            {
                                "input_ids_check": ctx_logs[0],
                                "real_tokens_count": ctx_logs[1],
                                "tokenizer_pad_token": ctx_logs[2],
                                "tokenizer_eos_token": ctx_logs[3],
                                "tokenizer_bos_token": ctx_logs[4],
                                "attr_batch_size": ctx_logs[5],
                                "attr_max_length": ctx_logs[6],
                            },
                        ]
                    ]
                )

        return re_ord.get_original(res)

    def greedy_until(self, requests, task=None, num_generation=1):
        # TODO: implement fully general `until` that handles until that are
        #       multiple tokens or that span multiple tokens correctly

        # TODO: extract to TokenizedLM?
        res = []

        def _collate(x):
            # the negative sign on len(toks) sorts descending - this has a few advantages:
            # - time estimates will always be over not underestimates, which is more useful for planning
            # - to know the size of a batch when going through the list, you know the first one is always the batch
            #   padded context length. this is useful to simplify the batching logic and more importantly to make
            #   automatic adaptive batches much much easier to implement
            # - any OOMs will happen right away rather than near the end

            toks = self.tok_encode(x[0])
            return -len(toks), x[0]

        re_ord = utils.Reorderer(requests, _collate)

        warn_stop_seq = False
        for context, request_args in tqdm(re_ord.get_reordered()):
            until = request_args.get("until", self.tokenizer.eos_token)  # dirty, tokenizer may be undefined
            logs_ctx = {
                "until": until,
                "tokenizer_pad_token": [self.tokenizer.pad_token, self.tokenizer.pad_token_id],
                "tokenizer_eos_token": [self.tokenizer.eos_token, self.tokenizer.eos_token_id],
                "tokenizer_bos_token": [self.tokenizer.bos_token, self.tokenizer.bos_token_id],
                "attr_batch_size": self.batch_size,
                "attr_max_length": self.max_length,
                "attr_max_gen_toks": self.max_gen_toks,
            }
            if isinstance(until, str):
                until = [until]

            if until:
                try:
                    (primary_until,) = self.tok_encode(until[0])
                except ValueError:
                    if not warn_stop_seq:
                        print(
                            "Warning: a primary stop sequence is multi-token! Will default to EOS token for this "
                            "tokenizer. Consider using `hf-causal-experimental` for multi-token stop sequence support "
                            "for the time being."
                        )
                        warn_stop_seq = True
                    primary_until = self.eot_token_id
            else:
                primary_until = None

            context_enc = torch.tensor([self.tok_encode(context)[self.max_gen_toks - self.max_length :]]).to(
                self.device
            )
            logs_ctx["ctx_ids"] = context_enc.shape

            max_gen_tokens = min(self.max_gen_toks, request_args.get("max_length", self.max_gen_toks))
            logs_ctx["max_gen_tokens"] = max_gen_tokens
            logs_ctx["max_length"] = request_args.get("max_length", None)

            if task == "humaneval":
                try:
                    cont = self._model_generate(
                        context_enc, context_enc.shape[1] + max_gen_tokens, primary_until, task, num_generation
                    )
                except Exception as e:
                    error_msg = {
                        "header": "Error occurred while processing greedy_until requests",
                        "content": e,
                        "chunk": context,
                    }
                    print(error_msg)
                    raise
                s = [self.tok_decode(cont[it].tolist()[context_enc.shape[1] :]) for it in range(num_generation)]
                for elem in range(len(s)):
                    for term in until:
                        s[elem] = s[elem].split(term)[0]
                self.cache_hook.add_partial("greedy_until", (context, until), s)
                res.extend([[s, logs_ctx]])
            else:
                try:
                    cont = self._model_generate(context_enc, context_enc.shape[1] + max_gen_tokens, primary_until)
                except Exception as e:
                    error_msg = {
                        "header": "Error occurred while processing greedy_until requests",
                        "content": e,
                        "chunk": context,
                    }
                    print(error_msg)
                    raise
                s = self.tok_decode(cont[0].tolist()[context_enc.shape[1] :])

                for term in until:
                    s = s.split(term)[0]

                self.cache_hook.add_partial("greedy_until", (context, until), s)

                res.extend([[s, logs_ctx]])

        return re_ord.get_original(res)


class Task(abc.ABC):
    """A task represents an entire benchmark including its dataset, problems,
    answers, and evaluation methods. See BoolQ for a simple example implementation

    A `doc` can be any python object which represents one instance of evaluation.
    This is usually a dictionary e.g.
        {"question": ..., "answer": ...} or
        {"question": ..., question, answer)
    """

    # The name of the `Task` benchmark as denoted in the HuggingFace datasets Hub
    # or a path to a custom `datasets` loading script.
    DATASET_PATH: str = "ai-forever/MERA"

    # The name of a subset within `DATASET_PATH`.
    DATASET_NAME: str = None

    def __init__(self, data_dir=None, cache_dir=None, download_mode="force_redownload"):
        """
        :param data_dir: str
            Stores the path to a local folder containing the `Task`'s data files.
            Use this to specify the path to manually downloaded data (usually when
            the dataset is not publicly accessible).
        :param cache_dir: str
            The directory to read/write the `Task` dataset. This follows the
            HuggingFace `datasets` API with the default cache directory located at:
                `~/.cache/huggingface/datasets`
            NOTE: You can change the cache location globally for a given process
            by setting the shell environment variable, `HF_DATASETS_CACHE`,
            to another directory:
                `export HF_DATASETS_CACHE="/path/to/another/directory"`
        :param download_mode: datasets.DownloadMode
            How to treat pre-existing `Task` downloads and data.
            - `datasets.DownloadMode.REUSE_DATASET_IF_EXISTS`
                Reuse download and reuse dataset.
            - `datasets.DownloadMode.REUSE_CACHE_IF_EXISTS`
                Reuse download with fresh dataset.
            - `datasets.DownloadMode.FORCE_REDOWNLOAD`
                Fresh download and fresh dataset.
        """
        self.download(data_dir, cache_dir, download_mode)
        self._training_docs = None
        self._fewshot_docs = None

    def download(self, data_dir=None, cache_dir=None, download_mode="force_redownload"):
        """Downloads and returns the task dataset.
        Override this method to download the dataset from a custom API.

        :param data_dir: str
            Stores the path to a local folder containing the `Task`'s data files.
            Use this to specify the path to manually downloaded data (usually when
            the dataset is not publicly accessible).
        :param cache_dir: str
            The directory to read/write the `Task` dataset. This follows the
            HuggingFace `datasets` API with the default cache directory located at:
                `~/.cache/huggingface/datasets`
            NOTE: You can change the cache location globally for a given process
            by setting the shell environment variable, `HF_DATASETS_CACHE`,
            to another directory:
                `export HF_DATASETS_CACHE="/path/to/another/directory"`
        :param download_mode: datasets.DownloadMode
            How to treat pre-existing `Task` downloads and data.
            - `datasets.DownloadMode.REUSE_DATASET_IF_EXISTS`
                Reuse download and reuse dataset.
            - `datasets.DownloadMode.REUSE_CACHE_IF_EXISTS`
                Reuse download with fresh dataset.
            - `datasets.DownloadMode.FORCE_REDOWNLOAD`
                Fresh download and fresh dataset.
        """
        self.dataset = datasets.load_dataset(
            path=self.DATASET_PATH,
            name=self.DATASET_NAME,
            data_dir=data_dir,
            cache_dir=cache_dir,
            download_mode=download_mode,
        )

    def should_decontaminate(self):
        """Whether this task supports decontamination against model training set."""
        return False

    @abstractmethod
    def has_training_docs(self):
        """Whether the task has a training set"""
        pass

    @abstractmethod
    def has_validation_docs(self):
        """Whether the task has a validation set"""
        pass

    @abstractmethod
    def has_test_docs(self):
        """Whether the task has a test set"""
        pass

    def training_docs(self):
        """
        :return: Iterable[obj]
            A iterable of any object, that doc_to_text can handle
        """
        return []

    def validation_docs(self):
        """
        :return: Iterable[obj]
            A iterable of any object, that doc_to_text can handle
        """
        return []

    def test_docs(self):
        """
        :return: Iterable[obj]
            A iterable of any object, that doc_to_text can handle
        """
        return []

    def _process_doc(self, doc):
        """
        Override this to process (detokenize, strip, replace, etc.) individual
        documents. This can be used in a map over documents of a data split.
        E.g. `map(self._process_doc, self.dataset["validation"])`

        :return: dict
            The processed version of the specified `doc`.
        """
        return doc

    def fewshot_examples(self, k, rnd):
        if self._training_docs is None:
            self._training_docs = list(self.training_docs())

        return rnd.sample(self._training_docs, k)

    def doc_to_decontamination_query(self, doc):
        print("Override doc_to_decontamination_query with document specific decontamination query.")
        assert False

    @abstractmethod
    def doc_to_text(self, doc):
        pass

    def doc_to_text_without_instruction(self, doc):
        return self.doc_to_text(doc)

    @abstractmethod
    def doc_to_target(self, doc):
        pass

    @abstractmethod
    def construct_requests(self, doc, ctx):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """
        pass

    @abstractmethod
    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        pass

    @abstractmethod
    def aggregation(self):
        """
        :returns: {str: [metric_score] -> float}
            A dictionary where keys are the names of submetrics and values are
            functions that aggregate a list of metric scores
        """
        pass

    @abstractmethod
    def higher_is_better(self):
        """
        :returns: {str: bool}
            A dictionary where keys are the names of submetrics and values are
            whether a higher value of the submetric is better
        """
        pass

    def fewshot_description(self):
        import warnings

        warnings.warn(
            "`fewshot_description` will be removed in futures versions. Pass "
            "any custom descriptions to the `evaluate` function instead.",
            DeprecationWarning,
        )
        return ""

    @utils.positional_deprecated
    def fewshot_context(self, doc, num_fewshot, provide_description=None, rnd=None, description=None):
        """Returns a fewshot context string that is made up of a prepended description
        (if provided), the `num_fewshot` number of examples, and an appended prompt example.

        :param doc: str
            The document as returned from training_docs, validation_docs, or test_docs.
        :param num_fewshot: int
            The number of fewshot examples to provide in the returned context string.
        :param provide_description: bool
            Not implemented, and this option is deprecated and will be removed in a future version in favor of a different description providing method
        :param rnd: random.Random
            The pseudo-random number generator used to randomly sample examples.
            WARNING: This is currently a required arg although it's optionalized with a default `None`.
        :param description: str
            The task's description that will be prepended to the fewshot examples.
        :returns: str
            The fewshot context.
        """
        assert rnd is not None, "A `random.Random` generator argument must be provided to `rnd`"
        assert not provide_description, (
            "The `provide_description` arg will be removed in future versions. To prepend "
            "a custom description to the context, supply the corresponding string via the "
            "`description` arg."
        )
        if provide_description is not None:
            # nudge people to not specify it at all
            print(
                "WARNING: provide_description is deprecated and will be removed in a future version in favor of description_dict"
            )

        description = description + "\n\n" if description else ""

        if num_fewshot == 0:
            labeled_examples = ""
            example = self.doc_to_text(doc)

        else:
            # for sets with no training docs, draw from other set *but ensure no overlap with current doc*
            if self.has_training_docs():
                fewshotex = self.fewshot_examples(k=num_fewshot, rnd=rnd)
            else:
                if self._fewshot_docs is None:
                    self._fewshot_docs = list(
                        self.validation_docs() if self.has_validation_docs() else self.test_docs()
                    )

                fewshotex = rnd.sample(self._fewshot_docs, num_fewshot + 1)

                # get rid of the doc that's the one we're evaluating, if it's in the fewshot
                fewshotex = [x for x in fewshotex if x != doc][:num_fewshot]

            labeled_examples = ""
            for idx_shot, shot_doc in enumerate(fewshotex):
                if idx_shot == 0:
                    shot = self.doc_to_text(shot_doc) + self.doc_to_target(shot_doc)
                else:
                    shot = self.doc_to_text_without_instruction(shot_doc) + self.doc_to_target(shot_doc)

                labeled_examples += shot
                labeled_examples += "\n\n"

            example = self.doc_to_text_without_instruction(doc)

        return description + labeled_examples + example


class MultipleChoiceTask(Task):
    def doc_to_target(self, doc):
        return " " + doc["choices"][doc["gold"]]

    def construct_requests(self, doc, ctx):
        lls = [rf.loglikelihood(ctx, " {}".format(choice))[0] for choice in doc["choices"]]

        return lls

    def process_results(self, doc, results):
        gold = doc["gold"]

        acc = 1.0 if np.argmax(results) == gold else 0.0
        completion_len = np.array([float(len(i)) for i in doc["choices"]])
        acc_norm = 1.0 if np.argmax(results / completion_len) == gold else 0.0

        return {
            "acc": acc,
            "acc_norm": acc_norm,
        }

    def higher_is_better(self):
        return {
            "acc": True,
            "acc_norm": True,
        }

    def aggregation(self):
        return {
            "acc": mean,
            "acc_norm": mean,
        }


class PerplexityTask(Task, abc.ABC):
    def should_decontaminate(self):
        """Whether this task supports decontamination against model training set."""
        return True

    def has_training_docs(self):
        return False

    def fewshot_examples(self, k, rnd):
        assert k == 0
        return []

    def fewshot_context(self, doc, num_fewshot, provide_description=None, rnd=None, description=None):
        assert num_fewshot == 0, "The number of fewshot examples must be 0 for perplexity tasks."
        assert rnd is not None, "A `random.Random` generator argument must be provided to `rnd`."
        assert not provide_description, (
            "The `provide_description` arg will be removed in future versions. To prepend "
            "a custom description to the context, supply the corresponding string via the "
            "`description` arg."
        )
        if provide_description is not None:
            # nudge people to not specify it at all
            print(
                "WARNING: provide_description is deprecated and will be removed in a future version in favor of description_dict"
            )

        return ""

    def higher_is_better(self):
        return {
            "word_perplexity": False,
            "byte_perplexity": False,
            "bits_per_byte": False,
        }

    def doc_to_decontamination_query(self, doc):
        return doc

    def doc_to_text(self, doc):
        return ""

    def doc_to_target(self, doc):
        return doc

    def construct_requests(self, doc, ctx):
        assert not ctx
        req = rf.loglikelihood_rolling(self.doc_to_target(doc))
        return req

    def process_results(self, doc, results):
        (loglikelihood,) = results
        words = self.count_words(doc)
        bytes_ = self.count_bytes(doc)
        return {
            "word_perplexity": (loglikelihood, words),
            "byte_perplexity": (loglikelihood, bytes_),
            "bits_per_byte": (loglikelihood, bytes_),
        }

    def aggregation(self):
        return {
            "word_perplexity": weighted_perplexity,
            "byte_perplexity": weighted_perplexity,
            "bits_per_byte": bits_per_byte,
        }

    @classmethod
    def count_bytes(cls, doc):
        return len(doc.encode("utf-8"))

    @classmethod
    def count_words(cls, doc):
        """Downstream tasks with custom word boundaries should override this!"""
        return len(re.split(r"\s+", doc))


def hash_args(attr, args):
    dat = json.dumps([attr] + list(args))
    return hashlib.sha256(dat.encode("utf-8")).hexdigest()


class CacheHook:
    def __init__(self, cachinglm):
        if cachinglm is None:
            self.dbdict = None
            return

        self.dbdict = cachinglm.dbdict

    def add_partial(self, attr, req, res):
        if self.dbdict is None:
            return
        hsh = hash_args(attr, req)
        self.dbdict[hsh] = res


class CachingLM:
    def __init__(self, lm, cache_db):
        """LM wrapper that returns cached results if they exist, and uses the underlying LM if not.

        :param lm: LM
            Underlying LM
        :param cache_db: str
            Path to cache db
        """
        self.lm = lm
        self.cache_db = cache_db
        if os.path.dirname(cache_db):
            os.makedirs(os.path.dirname(cache_db), exist_ok=True)
        self.dbdict = SqliteDict(cache_db, autocommit=True)

        # add hook to lm
        lm.set_cache_hook(self.get_cache_hook())

    def __getattr__(self, attr):
        lm_attr = getattr(self.lm, attr)
        if not callable(lm_attr):
            return lm_attr

        def fn(requests, task=None, num_generation=1):
            res = []
            remaining_reqs = []

            # figure out which ones are cached and which ones are new
            for req in requests:
                hsh = hash_args(attr, req)
                if hsh in self.dbdict:
                    ob = self.dbdict[hsh]

                    assert ob is not None

                    res.append(ob)
                else:
                    res.append(None)
                    remaining_reqs.append(req)

            # actually run the LM on the requests that do not have cached results
            if task == "humaneval":
                rem_res = getattr(self.lm, attr)(remaining_reqs, task, num_generation)
            else:
                rem_res = getattr(self.lm, attr)(remaining_reqs)

            # stick the new ones back into the list and also cache any of the new ones
            resptr = 0
            for req, r in zip(remaining_reqs, rem_res):
                while res[resptr] is not None:
                    resptr += 1

                res[resptr] = r

                # caching
                hsh = hash_args(attr, req)
                self.dbdict[hsh] = r
            self.dbdict.commit()

            return res

        return fn

    def get_cache_hook(self):
        return CacheHook(self)


REQUEST_RETURN_LENGTHS = {
    "loglikelihood": 2,
    "greedy_until": None,
    "loglikelihood_rolling": None,
}


class Request:
    def __init__(self, request_type, args, index=None):
        if request_type not in REQUEST_RETURN_LENGTHS.keys():
            raise NotImplementedError("The request type {} is not implemented!".format(request_type))

        self.request_type = request_type
        self.args = args
        self.index = index

    def __iter__(self):
        if REQUEST_RETURN_LENGTHS[self.request_type] is None:
            raise IndexError("This request type does not return multiple arguments!")
        for i in range(REQUEST_RETURN_LENGTHS[self.request_type]):
            yield Request(self.request_type, self.args, i)

    def __getitem__(self, i):
        if REQUEST_RETURN_LENGTHS[self.request_type] is None:
            raise IndexError("This request type does not return multiple arguments!")
        return Request(self.request_type, self.args, i)

    def __eq__(self, other):
        return self.request_type == other.request_type and self.args == other.args and self.index == other.index

    def __repr__(self):
        return f"Req_{self.request_type}{self.args}[{self.index}]\n"


class RequestFactory:
    def __getattr__(self, attr):
        def fn(*args):
            return Request(attr, args)

        return fn


rf = RequestFactory()
